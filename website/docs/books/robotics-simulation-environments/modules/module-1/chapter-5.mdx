---
id: chapter-5
title: "Environment Modeling and Scene Generation"
module: "Module 1: Foundations of Robotics Simulation"
lessonTab: true
summaryTab: true
duration: 15
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs className="tabs-container">
<TabItem value="lesson" label="Full Lesson" default>
<div className="lesson-content">

## Lesson: Environment Modeling and Scene Generation

### Introduction to Environment Modeling

Environment modeling is the process of creating digital representations of physical spaces where robots operate. This involves generating 3D models of objects, surfaces, and spatial relationships that accurately reflect real-world environments. Effective environment modeling is critical for robotics simulation as it provides the context in which robots must operate and interact. This chapter explores the techniques, tools, and approaches used to create realistic and functional simulation environments.

### 3D Modeling Fundamentals

#### Geometric Representations

**Polygonal Meshes**:
The most common representation for 3D objects in simulation.

**Components**:
- **Vertices**: 3D points that define the shape
- **Edges**: Lines connecting vertices
- **Faces**: Polygons defined by vertices
- **Normals**: Perpendicular vectors for lighting calculations

**Types of Meshes**:
- **Triangle Meshes**: Meshes composed of triangular faces
- **Quad Meshes**: Meshes composed of quadrilateral faces
- **Polygon Meshes**: Meshes with faces of varying sizes

**Mesh Quality Metrics**:
- **Vertex Count**: Number of vertices in the mesh
- **Face Count**: Number of faces in the mesh
- **Edge Length**: Length of edges (should be uniform)
- **Face Area**: Area of faces (should be consistent)
- **Aspect Ratio**: Ratio of longest to shortest edge

**Mathematical Representation**:
```
Vertices: V = {v₁, v₂, ..., vₙ} where vᵢ ∈ ℝ³
Faces: F = {f₁, f₂, ..., fₘ} where fⱼ = {vᵢ₁, vᵢ₂, vᵢ₃}
```

**Implementation Example**:
```cpp
struct Vertex {
    float x, y, z;           // Position
    float nx, ny, nz;        // Normal
    float u, v;              // UV coordinates
};

struct Triangle {
    int vertex_indices[3];   // Indices into vertex array
    int normal_indices[3];   // Indices into normal array
};

class Mesh {
private:
    std::vector<Vertex> vertices;
    std::vector<Triangle> triangles;
    std::vector<float> normals;

public:
    void addVertex(float x, float y, float z) {
        Vertex v = {x, y, z, 0, 0, 0, 0, 0};
        vertices.push_back(v);
    }

    void addTriangle(int v1, int v2, int v3) {
        Triangle t = {{v1, v2, v3}, {v1, v2, v3}};
        triangles.push_back(t);
    }

    void computeNormals() {
        // Compute face normals
        for (auto& tri : triangles) {
            Vertex& v1 = vertices[tri.vertex_indices[0]];
            Vertex& v2 = vertices[tri.vertex_indices[1]];
            Vertex& v3 = vertices[tri.vertex_indices[2]];

            // Calculate face normal
            Vector3d edge1 = {v2.x - v1.x, v2.y - v1.y, v2.z - v1.z};
            Vector3d edge2 = {v3.x - v1.x, v3.y - v1.y, v3.z - v1.z};
            Vector3d normal = cross_product(edge1, edge2).normalize();

            // Assign to vertices
            vertices[tri.vertex_indices[0]].nx = normal.x;
            vertices[tri.vertex_indices[0]].ny = normal.y;
            vertices[tri.vertex_indices[0]].nz = normal.z;
            // ... repeat for other vertices
        }
    }
};
```

#### Primitive Shapes

**Basic Geometric Primitives**:
Simple shapes used as building blocks for complex models.

**Common Primitives**:
- **Cube**: Rectangular parallelepiped
- **Sphere**: Perfectly round object
- **Cylinder**: Circular cross-section tube
- **Cone**: Tapered shape
- **Plane**: Infinite flat surface
- **Capsule**: Cylinder with hemispherical ends

**Parametric Definitions**:
```cpp
class PrimitiveFactory {
public:
    static Mesh createCube(float size) {
        Mesh cube;
        float half = size / 2.0f;
        
        // Define vertices for a cube
        cube.addVertex(-half, -half, -half);  // 0
        cube.addVertex(half, -half, -half);   // 1
        cube.addVertex(half, half, -half);    // 2
        cube.addVertex(-half, half, -half);   // 3
        cube.addVertex(-half, -half, half);   // 4
        cube.addVertex(half, -half, half);    // 5
        cube.addVertex(half, half, half);     // 6
        cube.addVertex(-half, half, half);    // 7
        
        // Define triangles (faces)
        // Front face
        cube.addTriangle(0, 1, 2); cube.addTriangle(0, 2, 3);
        // Back face
        cube.addTriangle(5, 4, 7); cube.addTriangle(5, 7, 6);
        // Left face
        cube.addTriangle(4, 0, 3); cube.addTriangle(4, 3, 7);
        // Right face
        cube.addTriangle(1, 5, 6); cube.addTriangle(1, 6, 2);
        // Top face
        cube.addTriangle(3, 2, 6); cube.addTriangle(3, 6, 7);
        // Bottom face
        cube.addTriangle(4, 5, 1); cube.addTriangle(4, 1, 0);
        
        return cube;
    }

    static Mesh createSphere(float radius, int segments = 32) {
        Mesh sphere;
        
        // Generate vertices using spherical coordinates
        for (int i = 0; i <= segments; i++) {
            float phi = M_PI * i / segments;  // 0 to π
            
            for (int j = 0; j <= segments; j++) {
                float theta = 2 * M_PI * j / segments;  // 0 to 2π
                
                float x = radius * sin(phi) * cos(theta);
                float y = radius * cos(phi);
                float z = radius * sin(phi) * sin(theta);
                
                sphere.addVertex(x, y, z);
            }
        }
        
        // Generate triangles
        for (int i = 0; i < segments; i++) {
            for (int j = 0; j < segments; j++) {
                int first = i * (segments + 1) + j;
                int second = first + segments + 1;
                
                // First triangle
                sphere.addTriangle(first, second, first + 1);
                // Second triangle
                sphere.addTriangle(second, second + 1, first + 1);
            }
        }
        
        return sphere;
    }

    static Mesh createCylinder(float radius, float height, int segments = 32) {
        Mesh cylinder;
        float half_height = height / 2.0f;
        
        // Top cap
        cylinder.addVertex(0, half_height, 0);  // Top center
        for (int i = 0; i <= segments; i++) {
            float theta = 2 * M_PI * i / segments;
            float x = radius * cos(theta);
            float z = radius * sin(theta);
            cylinder.addVertex(x, half_height, z);  // Top edge
        }
        
        // Bottom cap
        cylinder.addVertex(0, -half_height, 0);  // Bottom center
        for (int i = 0; i <= segments; i++) {
            float theta = 2 * M_PI * i / segments;
            float x = radius * cos(theta);
            float z = radius * sin(theta);
            cylinder.addVertex(x, -half_height, z);  // Bottom edge
        }
        
        // Side faces
        for (int i = 0; i < segments; i++) {
            int top_edge1 = i + 1;
            int top_edge2 = (i + 1) % segments + 1;
            int bottom_edge1 = segments + 2 + i;
            int bottom_edge2 = segments + 2 + (i + 1) % segments;
            
            // Side triangles
            cylinder.addTriangle(top_edge1, top_edge2, bottom_edge1);
            cylinder.addTriangle(bottom_edge1, top_edge2, bottom_edge2);
        }
        
        // Cap triangles
        for (int i = 0; i < segments; i++) {
            // Top cap
            cylinder.addTriangle(0, i + 1, (i + 1) % segments + 1);
            // Bottom cap
            int bottom_center = segments + 1;
            int bottom_offset = segments + 2;
            cylinder.addTriangle(bottom_center, bottom_offset + (i + 1) % segments, 
                               bottom_offset + i);
        }
        
        return cylinder;
    }
};
```

#### Advanced Geometric Representations

**Constructive Solid Geometry (CSG)**:
Combining primitive shapes using Boolean operations.

**Operations**:
- **Union**: Combine two shapes
- **Intersection**: Overlapping regions
- **Difference**: Subtract one shape from another

**Mathematical Representation**:
```
A ∪ B: Union of shapes A and B
A ∩ B: Intersection of shapes A and B
A \ B: Difference (A minus B)
```

**Implementation Example**:
```cpp
class CSGNode {
public:
    enum Operation { UNION, INTERSECTION, DIFFERENCE };
    
    CSGNode(Operation op, CSGNode* left, CSGNode* right) 
        : operation(op), left_child(left), right_child(right), is_primitive(false) {}
    
    CSGNode(const Mesh& mesh) : primitive_mesh(mesh), is_primitive(true) {}
    
    Mesh evaluate() {
        if (is_primitive) {
            return primitive_mesh;
        }
        
        Mesh left_mesh = left_child->evaluate();
        Mesh right_mesh = right_child->evaluate();
        
        switch (operation) {
            case UNION:
                return boolean_union(left_mesh, right_mesh);
            case INTERSECTION:
                return boolean_intersection(left_mesh, right_mesh);
            case DIFFERENCE:
                return boolean_difference(left_mesh, right_mesh);
            default:
                return left_mesh;
        }
    }

private:
    Operation operation;
    CSGNode* left_child;
    CSGNode* right_child;
    Mesh primitive_mesh;
    bool is_primitive;
    
    // Boolean operations implementation would go here
    Mesh boolean_union(const Mesh& a, const Mesh& b) { /* implementation */ return a; }
    Mesh boolean_intersection(const Mesh& a, const Mesh& b) { /* implementation */ return a; }
    Mesh boolean_difference(const Mesh& a, const Mesh& b) { /* implementation */ return a; }
};
```

### Scene Representation

#### Scene Graph Architecture

**Concept**:
A hierarchical data structure that represents the relationships between objects in a scene.

**Components**:
- **Nodes**: Represent objects, transformations, or groups
- **Transforms**: Position, rotation, and scale information
- **Parents/Children**: Hierarchical relationships
- **Materials**: Surface properties and appearance

**Scene Node Structure**:
```cpp
class SceneNode {
protected:
    std::string name;
    Matrix4x4 local_transform;
    Matrix4x4 world_transform;
    std::vector<std::unique_ptr<SceneNode>> children;
    SceneNode* parent;
    
    // Scene-specific data
    std::vector<Mesh> meshes;
    std::vector<Material> materials;
    std::vector<Texture> textures;

public:
    SceneNode(const std::string& node_name) : name(node_name), parent(nullptr) {
        // Initialize identity transform
        local_transform = Matrix4x4::identity();
        world_transform = Matrix4x4::identity();
    }
    
    void addChild(std::unique_ptr<SceneNode> child) {
        child->parent = this;
        children.push_back(std::move(child));
    }
    
    void setTransform(const Matrix4x4& transform) {
        local_transform = transform;
        updateWorldTransform();
    }
    
    void updateWorldTransform() {
        if (parent) {
            world_transform = parent->getWorldTransform() * local_transform;
        } else {
            world_transform = local_transform;
        }
        
        // Propagate to children
        for (auto& child : children) {
            child->updateWorldTransform();
        }
    }
    
    Matrix4x4 getWorldTransform() const { return world_transform; }
    
    virtual void render(Renderer& renderer) {
        // Apply world transform
        renderer.setTransform(world_transform);
        
        // Render own meshes
        for (const auto& mesh : meshes) {
            renderer.render(mesh);
        }
        
        // Render children
        for (auto& child : children) {
            child->render(renderer);
        }
    }
    
    virtual void update(float deltaTime) {
        // Update node-specific behavior
        for (auto& child : children) {
            child->update(deltaTime);
        }
    }
};
```

#### Spatial Partitioning

**Purpose**:
Efficiently organizing objects in space for collision detection and rendering.

**Octree**:
Hierarchical subdivision of 3D space into eight octants.

**Structure**:
```cpp
class OctreeNode {
private:
    BoundingBox bounds;                    // Spatial bounds
    std::vector<Object*> objects;          // Objects in this node
    std::vector<std::unique_ptr<OctreeNode>> children;  // Child octants
    int max_objects;                       // Max objects before subdivision
    int max_depth;                         // Maximum tree depth
    int current_depth;                     // Current depth in tree

public:
    OctreeNode(const BoundingBox& bbox, int max_objs = 10, int max_dep = 10, int cur_depth = 0)
        : bounds(bbox), max_objects(max_objs), max_depth(max_dep), current_depth(cur_depth) {
        objects.reserve(max_objects);
        children.reserve(8);
    }

    bool addObject(Object* obj) {
        if (!bounds.contains(obj->getBounds())) {
            return false;  // Object doesn't belong to this node
        }

        if (children.empty() && objects.size() < max_objects && current_depth < max_depth) {
            objects.push_back(obj);
            return true;
        }

        // Subdivide if needed
        if (children.empty()) {
            subdivide();
        }

        // Try to add to children
        for (auto& child : children) {
            if (child->addObject(obj)) {
                return true;
            }
        }

        // If object spans multiple children, keep in this node
        objects.push_back(obj);
        return true;
    }

    void subdivide() {
        Vector3d center = bounds.getCenter();
        float half_size = bounds.getSize().x / 2.0f;

        // Create 8 child octants
        for (int x = 0; x < 2; x++) {
            for (int y = 0; y < 2; y++) {
                for (int z = 0; z < 2; z++) {
                    Vector3d offset(x * half_size, y * half_size, z * half_size);
                    Vector3d new_min = center - Vector3d(half_size, half_size, half_size) + offset;
                    Vector3d new_max = center + Vector3d(half_size, half_size, half_size) + offset;
                    
                    BoundingBox child_bounds(new_min, new_max);
                    children.push_back(std::make_unique<OctreeNode>(
                        child_bounds, max_objects, max_depth, current_depth + 1));
                }
            }
        }

        // Redistribute existing objects to children
        auto objects_to_relocate = std::move(objects);
        for (auto obj : objects_to_relocate) {
            for (auto& child : children) {
                if (child->addObject(obj)) {
                    break;
                }
            }
        }
    }

    std::vector<Object*> getNearbyObjects(const BoundingBox& query_bounds) {
        std::vector<Object*> nearby_objects;

        // Check objects in this node
        for (auto obj : objects) {
            if (obj->getBounds().intersects(query_bounds)) {
                nearby_objects.push_back(obj);
            }
        }

        // Check children if they exist
        if (!children.empty()) {
            for (auto& child : children) {
                if (child->getBounds().intersects(query_bounds)) {
                    auto child_objects = child->getNearbyObjects(query_bounds);
                    nearby_objects.insert(nearby_objects.end(), 
                                        child_objects.begin(), child_objects.end());
                }
            }
        }

        return nearby_objects;
    }
};
```

**KD-tree**:
Binary space partitioning along coordinate axes.

**Structure**:
```cpp
class KDTreeNode {
private:
    BoundingBox bounds;
    std::vector<Object*> objects;
    std::unique_ptr<KDTreeNode> left;
    std::unique_ptr<KDTreeNode> right;
    int split_axis;  // 0=X, 1=Y, 2=Z
    float split_value;
    int max_objects;
    int max_depth;
    int current_depth;

public:
    KDTreeNode(const BoundingBox& bbox, int max_objs = 10, int max_dep = 10, int cur_depth = 0)
        : bounds(bbox), max_objects(max_objs), max_depth(max_dep), current_depth(cur_depth) {
        split_axis = -1;
        split_value = 0.0f;
    }

    void build(const std::vector<Object*>& objs) {
        objects = objs;

        if (objects.size() <= max_objects || current_depth >= max_depth) {
            return;  // Leaf node
        }

        // Determine best split axis and value
        determineSplit();

        // Partition objects
        std::vector<Object*> left_objects, right_objects;
        for (auto obj : objects) {
            float obj_coord = getSplitCoordinate(obj);
            if (obj_coord <= split_value) {
                left_objects.push_back(obj);
            } else {
                right_objects.push_back(obj);
            }
        }

        // Create bounding boxes for children
        BoundingBox left_bounds = bounds;
        BoundingBox right_bounds = bounds;
        
        switch (split_axis) {
            case 0:  // X-axis
                left_bounds.setMaxX(split_value);
                right_bounds.setMinX(split_value);
                break;
            case 1:  // Y-axis
                left_bounds.setMaxY(split_value);
                right_bounds.setMinY(split_value);
                break;
            case 2:  // Z-axis
                left_bounds.setMaxZ(split_value);
                right_bounds.setMinZ(split_value);
                break;
        }

        // Create child nodes
        left = std::make_unique<KDTreeNode>(left_bounds, max_objects, max_depth, current_depth + 1);
        right = std::make_unique<KDTreeNode>(right_bounds, max_objects, max_depth, current_depth + 1);

        left->build(left_objects);
        right->build(right_objects);
    }

private:
    void determineSplit() {
        // Calculate split based on object distribution
        Vector3d size = bounds.getSize();
        
        // Choose axis with largest dimension
        if (size.x >= size.y && size.x >= size.z) {
            split_axis = 0;
        } else if (size.y >= size.z) {
            split_axis = 1;
        } else {
            split_axis = 2;
        }

        // Calculate median value along split axis
        std::vector<float> coords;
        for (auto obj : objects) {
            coords.push_back(getSplitCoordinate(obj));
        }
        
        std::sort(coords.begin(), coords.end());
        split_value = coords[coords.size() / 2];
    }

    float getSplitCoordinate(Object* obj) {
        Vector3d center = obj->getBounds().getCenter();
        switch (split_axis) {
            case 0: return center.x;
            case 1: return center.y;
            case 2: return center.z;
            default: return 0.0f;
        }
    }
};
```

### Material and Surface Properties

#### Material Definition

**Physical Material Properties**:
Defining how surfaces interact with light and physics.

**Properties**:
- **Diffuse Color**: Base color of the material
- **Specular Color**: Highlight color
- **Roughness**: Surface smoothness
- **Metallic**: Metallic vs. non-metallic
- **Normal Map**: Surface normal variations
- **Occlusion**: Ambient occlusion

**Material Structure**:
```cpp
class Material {
public:
    // Color properties
    Vector3d diffuse_color;      // Base color
    Vector3d specular_color;     // Specular highlight color
    Vector3d emissive_color;     // Emissive color
    float alpha;                 // Transparency
    
    // Physical properties
    float roughness;             // Surface roughness (0-1)
    float metallic;              // Metallic factor (0-1)
    float specular;              // Specular factor
    float opacity;               // Opacity (0-1)
    
    // Textures
    std::string diffuse_texture;     // Diffuse map path
    std::string normal_texture;      // Normal map path
    std::string roughness_texture;   // Roughness map path
    std::string metallic_texture;    // Metallic map path
    std::string occlusion_texture;   // Ambient occlusion map
    std::string emissive_texture;    // Emissive map
    
    // Physics properties
    float friction;              // Friction coefficient
    float restitution;           // Bounciness (0-1)
    float density;               // Material density
    bool is_static;              // Whether object moves

    Material() : 
        diffuse_color(0.8f, 0.8f, 0.8f),
        specular_color(1.0f, 1.0f, 1.0f),
        emissive_color(0.0f, 0.0f, 0.0f),
        alpha(1.0f),
        roughness(0.5f),
        metallic(0.0f),
        specular(0.2f),
        opacity(1.0f),
        friction(0.5f),
        restitution(0.1f),
        density(1000.0f),
        is_static(false) {}

    // Calculate surface properties for rendering
    Vector3d getDiffuseFactor(const Vector2d& uv) const {
        if (!diffuse_texture.empty()) {
            // Sample texture at UV coordinates
            return sampleTexture(diffuse_texture, uv);
        }
        return diffuse_color;
    }

    float getRoughnessFactor(const Vector2d& uv) const {
        if (!roughness_texture.empty()) {
            Vector3d tex_value = sampleTexture(roughness_texture, uv);
            return tex_value.x;  // Use R channel
        }
        return roughness;
    }

    float getMetallicFactor(const Vector2d& uv) const {
        if (!metallic_texture.empty()) {
            Vector3d tex_value = sampleTexture(metallic_texture, uv);
            return tex_value.x;  // Use R channel
        }
        return metallic;
    }

private:
    Vector3d sampleTexture(const std::string& texture_path, const Vector2d& uv) const {
        // Implementation would load and sample texture
        // For now, return white
        return Vector3d(1.0f, 1.0f, 1.0f);
    }
};
```

#### Physics Materials

**Friction Models**:
Different approaches to modeling surface friction.

**Coulomb Friction**:
```
F_friction ≤ μ * F_normal
```

**Types of Friction**:
- **Static Friction**: μ_static (prevents motion)
- **Dynamic Friction**: μ_dynamic (opposes motion)

**Implementation**:
```cpp
class PhysicsMaterial {
public:
    float static_friction;      // Static friction coefficient
    float dynamic_friction;     // Dynamic friction coefficient
    float restitution;          // Coefficient of restitution (bounciness)
    float density;              // Material density
    float rolling_friction;     // Rolling friction coefficient
    float spinning_friction;    // Spinning friction coefficient

    PhysicsMaterial(float static_fric = 0.5f, 
                   float dynamic_fric = 0.3f,
                   float rest = 0.1f,
                   float dens = 1000.0f,
                   float roll_fric = 0.1f,
                   float spin_fric = 0.1f) :
        static_friction(static_fric),
        dynamic_friction(dynamic_fric),
        restitution(rest),
        density(dens),
        rolling_friction(roll_fric),
        spinning_friction(spin_fric) {}

    // Calculate friction force
    float calculateFrictionForce(float normal_force, bool is_sliding) const {
        if (is_sliding) {
            return dynamic_friction * normal_force;
        } else {
            return static_friction * normal_force;
        }
    }

    // Calculate impulse for collision response
    float calculateRestitutionImpulse(float relative_velocity, float mass1, float mass2) const {
        float effective_mass = (mass1 * mass2) / (mass1 + mass2);
        return restitution * effective_mass * relative_velocity;
    }
};
```

### Procedural Environment Generation

#### Procedural Terrain Generation

**Concept**:
Automatically generating terrain using algorithms rather than manual modeling.

**Perlin Noise**:
Smooth, natural-looking noise function.

**Implementation**:
```cpp
class PerlinNoise {
private:
    int permutation[512];
    int seed;

public:
    PerlinNoise(int s = 1) : seed(s) {
        // Initialize permutation table
        for (int i = 0; i < 256; i++) {
            permutation[i] = i;
        }
        
        // Shuffle based on seed
        std::srand(seed);
        for (int i = 0; i < 256; i++) {
            int j = std::rand() % 256;
            std::swap(permutation[i], permutation[j]);
        }
        
        // Duplicate permutation table
        for (int i = 0; i < 256; i++) {
            permutation[256 + i] = permutation[i];
        }
    }

    float noise(float x, float y, float z) {
        // Find unit cube that contains point
        int X = (int)floor(x) & 255;
        int Y = (int)floor(y) & 255;
        int Z = (int)floor(z) & 255;

        // Find relative x,y,z of point in cube
        x -= floor(x);
        y -= floor(y);
        z -= floor(z);

        // Compute fade curves for x, y, z
        float u = fade(x);
        float v = fade(y);
        float w = fade(z);

        // Hash coordinates of the 8 cube corners
        int A = permutation[X] + Y;
        int AA = permutation[A] + Z;
        int AB = permutation[A + 1] + Z;
        int B = permutation[X + 1] + Y;
        int BA = permutation[B] + Z;
        int BB = permutation[B + 1] + Z;

        // Add blended results from 8 corners of cube
        return lerp(w, lerp(v, lerp(u, grad(permutation[AA], x, y, z),
                                     grad(permutation[BA], x - 1, y, z)),
                              lerp(u, grad(permutation[AB], x, y - 1, z),
                                   grad(permutation[BB], x - 1, y - 1, z))),
                    lerp(v, lerp(u, grad(permutation[AA + 1], x, y, z - 1),
                                 grad(permutation[BA + 1], x - 1, y, z - 1)),
                         lerp(u, grad(permutation[AB + 1], x, y - 1, z - 1),
                              grad(permutation[BB + 1], x - 1, y - 1, z - 1))));
    }

    float octaveNoise(float x, float y, float z, int octaves, float persistence) {
        float total = 0;
        float frequency = 1;
        float amplitude = 1;
        float maxValue = 0;  // Used for normalizing result to 0.0 - 1.0

        for (int i = 0; i < octaves; i++) {
            total += noise(x * frequency, y * frequency, z * frequency) * amplitude;
            maxValue += amplitude;

            amplitude *= persistence;
            frequency *= 2;
        }

        return total / maxValue;
    }

private:
    float fade(float t) { return t * t * t * (t * (t * 6 - 15) + 10); }
    float lerp(float t, float a, float b) { return a + t * (b - a); }
    float grad(int hash, float x, float y, float z) {
        int h = hash & 15;
        float u = h < 8 ? x : y;
        float v = h < 4 ? y : h == 12 || h == 14 ? x : z;
        return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);
    }
};
```

**Terrain Generation**:
```cpp
class TerrainGenerator {
private:
    PerlinNoise noise_generator;
    int width, height;
    float scale;
    int octaves;
    float persistence;

public:
    TerrainGenerator(int w, int h, float sc, int oct, float pers) :
        width(w), height(h), scale(sc), octaves(oct), persistence(pers) {}

    Mesh generateTerrain() {
        Mesh terrain;
        
        // Generate vertices
        for (int z = 0; z < height; z++) {
            for (int x = 0; x < width; x++) {
                float y = getHeight(x, z);
                terrain.addVertex(x, y, z);
            }
        }
        
        // Generate triangles
        for (int z = 0; z < height - 1; z++) {
            for (int x = 0; x < width - 1; x++) {
                int bl = z * width + x;      // Bottom-left
                int br = bl + 1;             // Bottom-right
                int tl = (z + 1) * width + x; // Top-left
                int tr = tl + 1;             // Top-right
                
                // First triangle
                terrain.addTriangle(bl, tl, br);
                // Second triangle
                terrain.addTriangle(br, tl, tr);
            }
        }
        
        return terrain;
    }

private:
    float getHeight(int x, int z) {
        float height = 0;
        float frequency = 1.0f;
        float amplitude = 1.0f;
        
        for (int i = 0; i < octaves; i++) {
            height += noise_generator.noise(
                (float)x / width * scale * frequency,
                0.0f,
                (float)z / height * scale * frequency
            ) * amplitude;
            
            amplitude *= persistence;
            frequency *= 2.0f;
        }
        
        return height;
    }
};
```

#### Procedural Object Placement

**Concept**:
Automatically placing objects in environments based on rules and distributions.

**Implementation**:
```cpp
class ProceduralPlacer {
public:
    struct PlacementRule {
        std::string object_type;
        float min_distance;      // Minimum distance to other objects
        float max_instances;     // Maximum number of instances
        float probability;       // Probability of placement
        BoundingBox bounds;      // Valid placement bounds
        std::function<bool(const Vector3d&)> placement_condition;  // Custom condition
    };

    static std::vector<SceneNode> placeObjects(
        const std::vector<PlacementRule>& rules,
        const BoundingBox& environment_bounds,
        int seed = 12345) {
        
        std::vector<SceneNode> placed_objects;
        std::mt19937 rng(seed);
        
        for (const auto& rule : rules) {
            int placed_count = 0;
            
            // Attempt to place objects up to max_instances
            for (int i = 0; i < rule.max_instances; i++) {
                if (placed_count >= rule.max_instances) break;
                
                // Check probability
                std::uniform_real_distribution<float> prob_dist(0.0f, 1.0f);
                if (prob_dist(rng) > rule.probability) continue;
                
                // Generate random position
                std::uniform_real_distribution<float> x_dist(
                    std::max(environment_bounds.getMinX(), rule.bounds.getMinX()),
                    std::min(environment_bounds.getMaxX(), rule.bounds.getMaxX())
                );
                std::uniform_real_distribution<float> y_dist(
                    std::max(environment_bounds.getMinY(), rule.bounds.getMinY()),
                    std::min(environment_bounds.getMaxY(), rule.bounds.getMaxY())
                );
                std::uniform_real_distribution<float> z_dist(
                    std::max(environment_bounds.getMinZ(), rule.bounds.getMinZ()),
                    std::min(environment_bounds.getMaxZ(), rule.bounds.getMaxZ())
                );
                
                Vector3d position(x_dist(rng), y_dist(rng), z_dist(rng));
                
                // Check placement conditions
                if (rule.placement_condition && !rule.placement_condition(position)) {
                    continue;
                }
                
                // Check minimum distance to other objects
                bool too_close = false;
                for (const auto& placed_obj : placed_objects) {
                    if (distance(position, placed_obj.getPosition()) < rule.min_distance) {
                        too_close = true;
                        break;
                    }
                }
                
                if (!too_close) {
                    // Create and place object
                    SceneNode new_object(rule.object_type);
                    new_object.setTransform(createTranslationMatrix(position));
                    placed_objects.push_back(std::move(new_object));
                    placed_count++;
                }
            }
        }
        
        return placed_objects;
    }

private:
    static float distance(const Vector3d& a, const Vector3d& b) {
        Vector3d diff = a - b;
        return sqrt(diff.x * diff.x + diff.y * diff.y + diff.z * diff.z);
    }
    
    static Matrix4x4 createTranslationMatrix(const Vector3d& pos) {
        Matrix4x4 transform = Matrix4x4::identity();
        transform[0][3] = pos.x;
        transform[1][3] = pos.y;
        transform[2][3] = pos.z;
        return transform;
    }
};
```

### Real-world Environment Modeling

#### Point Cloud Processing

**Concept**:
Converting 3D point cloud data into usable 3D models.

**Point Cloud Structure**:
```cpp
struct PointCloud {
    std::vector<Vector3d> points;
    std::vector<Vector3d> colors;    // RGB colors for each point
    std::vector<Vector3d> normals;   // Surface normals for each point
    std::vector<int> indices;        // Optional: connectivity information

    // Statistics
    Vector3d min_bound;
    Vector3d max_bound;
    Vector3d center;
    float density;                   // Points per unit volume

    PointCloud() : density(0.0f) {}

    void calculateBounds() {
        if (points.empty()) return;

        min_bound = max_bound = points[0];
        for (const auto& point : points) {
            min_bound.x = std::min(min_bound.x, point.x);
            min_bound.y = std::min(min_bound.y, point.y);
            min_bound.z = std::min(min_bound.z, point.z);
            max_bound.x = std::max(max_bound.x, point.x);
            max_bound.y = std::max(max_bound.y, point.y);
            max_bound.z = std::max(max_bound.z, point.z);
        }

        center = (min_bound + max_bound) * 0.5f;
    }

    float getVolume() const {
        Vector3d size = max_bound - min_bound;
        return size.x * size.y * size.z;
    }

    void calculateDensity() {
        float vol = getVolume();
        if (vol > 0) {
            density = static_cast<float>(points.size()) / vol;
        }
    }

    // Downsample point cloud to reduce density
    PointCloud downsample(float target_density) const {
        PointCloud downsampled;
        float ratio = target_density / density;
        
        std::mt19937 rng(12345);
        std::uniform_real_distribution<float> dist(0.0f, 1.0f);
        
        for (size_t i = 0; i < points.size(); i++) {
            if (dist(rng) < ratio) {
                downsampled.points.push_back(points[i]);
                if (i < colors.size()) downsampled.colors.push_back(colors[i]);
                if (i < normals.size()) downsampled.normals.push_back(normals[i]);
            }
        }
        
        downsampled.calculateBounds();
        downsampled.calculateDensity();
        return downsampled;
    }
};
```

**Surface Reconstruction**:
Converting point clouds to mesh surfaces.

```cpp
class SurfaceReconstructor {
public:
    // Poisson surface reconstruction approach
    static Mesh reconstructPoisson(const PointCloud& pc, float voxel_size = 0.01f) {
        // This is a simplified representation
        // Actual implementation would use Poisson reconstruction algorithm
        
        Mesh mesh;
        
        // Create voxel grid
        VoxelGrid grid(pc.min_bound, pc.max_bound, voxel_size);
        
        // Fill grid with point data
        for (const auto& point : pc.points) {
            grid.addValue(point, 1.0f);
        }
        
        // Extract iso-surface
        mesh = grid.extractIsoSurface(0.5f);
        
        return mesh;
    }

    // Alpha shapes approach
    static Mesh reconstructAlphaShapes(const PointCloud& pc, float alpha = 0.1f) {
        // Simplified representation
        // Actual implementation would use Delaunay triangulation
        
        Mesh mesh;
        
        // This would typically involve:
        // 1. Computing Delaunay triangulation of points
        // 2. Filtering tetrahedra based on alpha value
        // 3. Extracting boundary triangles
        
        return mesh;
    }

private:
    class VoxelGrid {
    private:
        Vector3i dimensions;  // Grid dimensions
        std::vector<float> values;  // SDF values
        Vector3d min_bound;
        float voxel_size;

    public:
        VoxelGrid(const Vector3d& min_b, const Vector3d& max_b, float vox_size) 
            : min_bound(min_b), voxel_size(vox_size) {
            dimensions.x = static_cast<int>((max_b.x - min_b.x) / vox_size) + 1;
            dimensions.y = static_cast<int>((max_b.y - min_b.y) / vox_size) + 1;
            dimensions.z = static_cast<int>((max_b.z - min_b.z) / vox_size) + 1;
            
            values.resize(dimensions.x * dimensions.y * dimensions.z, 0.0f);
        }

        void addValue(const Vector3d& point, float value) {
            Vector3i idx = worldToGrid(point);
            if (isValidIndex(idx)) {
                int linear_idx = idx.z * dimensions.x * dimensions.y + 
                                idx.y * dimensions.x + idx.x;
                values[linear_idx] += value;
            }
        }

        Mesh extractIsoSurface(float iso_value) {
            // Marching cubes algorithm implementation
            Mesh mesh;
            
            // This would implement marching cubes to extract iso-surface
            // from the voxel grid based on iso_value
            
            return mesh;
        }

    private:
        Vector3i worldToGrid(const Vector3d& world_pos) {
            Vector3i grid_pos;
            grid_pos.x = static_cast<int>((world_pos.x - min_bound.x) / voxel_size);
            grid_pos.y = static_cast<int>((world_pos.y - min_bound.y) / voxel_size);
            grid_pos.z = static_cast<int>((world_pos.z - min_bound.z) / voxel_size);
            return grid_pos;
        }

        bool isValidIndex(const Vector3i& idx) {
            return idx.x >= 0 && idx.x < dimensions.x &&
                   idx.y >= 0 && idx.y < dimensions.y &&
                   idx.z >= 0 && idx.z < dimensions.z;
        }
    };
};
```

### Environment Simulation Considerations

#### Performance Optimization

**Level of Detail (LOD)**:
Adjusting model complexity based on viewing distance.

**Implementation**:
```cpp
class LODManager {
private:
    struct LODLevel {
        Mesh mesh;
        float distance_threshold;  // Max distance to use this level
        int triangle_count;        // Number of triangles
    };

    std::vector<LODLevel> lod_levels;
    float current_distance;
    int active_lod;

public:
    void addLODLevel(const Mesh& mesh, float distance_thresh) {
        LODLevel level;
        level.mesh = mesh;
        level.distance_threshold = distance_thresh;
        level.triangle_count = mesh.getTriangleCount();
        lod_levels.push_back(level);
        
        // Sort by distance threshold
        std::sort(lod_levels.begin(), lod_levels.end(),
                 [](const LODLevel& a, const LODLevel& b) {
                     return a.distance_threshold < b.distance_threshold;
                 });
    }

    const Mesh& getActiveMesh(float viewer_distance) {
        // Find appropriate LOD level
        for (int i = lod_levels.size() - 1; i >= 0; i--) {
            if (viewer_distance <= lod_levels[i].distance_threshold) {
                active_lod = i;
                return lod_levels[i].mesh;
            }
        }
        
        // Return lowest detail level if no match
        active_lod = 0;
        return lod_levels[0].mesh;
    }

    // Generate LOD levels automatically
    static Mesh generateLOD(const Mesh& original, float reduction_factor) {
        // Implementation would use mesh decimation algorithms
        // like quadric error metrics or edge collapse
        return original;  // Placeholder
    }
};
```

#### Memory Management

**Streaming and Loading**:
Efficiently managing large environment data.

**Implementation**:
```cpp
class EnvironmentStreamer {
private:
    struct Chunk {
        BoundingBox bounds;
        std::vector<SceneNode> objects;
        bool loaded;
        bool visible;
        float last_access_time;
    };

    std::unordered_map<std::string, Chunk> chunks;
    std::queue<std::string> load_queue;
    int max_chunks_loaded;
    float unload_distance;

public:
    EnvironmentStreamer(int max_loaded = 100, float unload_dist = 100.0f) 
        : max_chunks_loaded(max_loaded), unload_distance(unload_dist) {}

    void updateVisibility(const Vector3d& viewer_position) {
        // Calculate visibility for each chunk
        for (auto& pair : chunks) {
            Chunk& chunk = pair.second;
            chunk.visible = chunk.bounds.contains(viewer_position) ||
                           distance(chunk.bounds.getCenter(), viewer_position) < 
                           chunk.bounds.getSize().length() + unload_distance;
        }

        // Manage loading/unloading
        manageMemory(viewer_position);
    }

    void loadChunk(const std::string& chunk_id, const std::string& file_path) {
        if (chunks.count(chunk_id) == 0) {
            chunks[chunk_id] = Chunk();
        }

        Chunk& chunk = chunks[chunk_id];
        if (!chunk.loaded) {
            // Load chunk data from file
            chunk.objects = loadChunkFromFile(file_path);
            chunk.loaded = true;
            chunk.last_access_time = getCurrentTime();
        }
    }

private:
    void manageMemory(const Vector3d& viewer_position) {
        // Count currently loaded chunks
        int loaded_count = 0;
        for (const auto& pair : chunks) {
            if (pair.second.loaded) loaded_count++;
        }

        // Unload distant chunks if exceeding limit
        if (loaded_count > max_chunks_loaded) {
            std::vector<std::pair<std::string, float>> unload_candidates;
            
            for (const auto& pair : chunks) {
                const Chunk& chunk = pair.second;
                if (chunk.loaded && !chunk.visible) {
                    float dist = distance(chunk.bounds.getCenter(), viewer_position);
                    unload_candidates.push_back({pair.first, dist});
                }
            }

            // Sort by distance (farthest first)
            std::sort(unload_candidates.begin(), unload_candidates.end(),
                     [](const auto& a, const auto& b) { return a.second > b.second; });

            // Unload excess chunks
            int to_unload = loaded_count - max_chunks_loaded;
            for (int i = 0; i < to_unload && i < unload_candidates.size(); i++) {
                unloadChunk(unload_candidates[i].first);
            }
        }
    }

    std::vector<SceneNode> loadChunkFromFile(const std::string& file_path) {
        // Implementation would load environment data from file
        return std::vector<SceneNode>();  // Placeholder
    }

    void unloadChunk(const std::string& chunk_id) {
        auto it = chunks.find(chunk_id);
        if (it != chunks.end()) {
            it->second.objects.clear();
            it->second.loaded = false;
        }
    }

    float getCurrentTime() {
        return static_cast<float>(std::chrono::duration_cast<std::chrono::seconds>(
            std::chrono::steady_clock::now().time_since_epoch()).count());
    }

    float distance(const Vector3d& a, const Vector3d& b) {
        Vector3d diff = a - b;
        return sqrt(diff.x * diff.x + diff.y * diff.y + diff.z * diff.z);
    }
};
```

Understanding environment modeling and scene generation is essential for creating realistic and efficient simulation environments that can support complex robotic systems and provide meaningful testing scenarios.

</div>
</TabItem>
<TabItem value="summary" label="Summary">
<div className="summary-content">

## Summary: Environment Modeling and Scene Generation

### 3D Modeling Fundamentals
- **Geometric Representations**: Polygonal meshes and primitives
- **Mesh Quality**: Vertex count, face area, aspect ratio metrics
- **Primitive Shapes**: Cube, sphere, cylinder, cone, capsule
- **CSG Operations**: Union, intersection, difference operations

### Scene Representation
- **Scene Graphs**: Hierarchical node structure
- **Spatial Partitioning**: Octree and KD-tree implementations
- **Transforms**: Position, rotation, scale in hierarchies
- **Optimization**: Frustum culling and occlusion culling

### Materials & Surface Properties
- **Physical Properties**: Diffuse, specular, roughness, metallic
- **Textures**: Diffuse, normal, roughness, metallic maps
- **Physics Materials**: Friction, restitution, density
- **PBR Shading**: Physically-based rendering parameters

### Procedural Generation
- **Perlin Noise**: Natural-looking procedural textures
- **Terrain Generation**: Heightmap-based landscape creation
- **Object Placement**: Rule-based automatic placement
- **Distributions**: Random, uniform, and conditional placement

### Real-world Modeling
- **Point Clouds**: Processing 3D scanner data
- **Surface Reconstruction**: Poisson and alpha shape methods
- **Voxel Grids**: Volumetric representation approaches
- **Marching Cubes**: Iso-surface extraction algorithms

### Performance Considerations
- **LOD Systems**: Level of detail based on distance
- **Memory Management**: Streaming and caching strategies
- **Optimization**: Occlusion and frustum culling
- **Real-time**: Balancing quality and performance

### Implementation Techniques
- **Data Structures**: Efficient storage and retrieval
- **Algorithms**: Spatial queries and proximity tests
- **Streaming**: Chunk-based environment loading
- **Caching**: Reusing computed geometric properties

</div>
</TabItem>
</Tabs>